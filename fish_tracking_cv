# to be run on raspberry pi, with opencv and picamera installed
try:
    import cv2
    import numpy as np
    from picamera2 import Picamera2 # for new library
    import serial
except ImportError:
    # Fallback for development on non-Raspberry Pi systems
    PiCamera = None
from time import sleep
import os
import time

def get_red_object_coordinates(image_path):
    image = cv2.imread(image_path)
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    lower_red = np.array([0, 70, 50])
    upper_red = np.array([10, 255, 255])
    mask = cv2.inRange(hsv, lower_red, upper_red)
    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        M = cv2.moments(largest_contour)
        if M["m00"] != 0:
            cX = int(M["m10"] / M["m00"])
            cY = int(M["m01"] / M["m00"])
            return (cX, cY)
    return None

def calculate_movement(coord1, coord2):
    if coord1 and coord2:
        distance = np.sqrt((coord2[0] - coord1[0])**2 + (coord2[1] - coord1[1])**2)
        direction = np.arctan2((coord2[1] - coord1[1]), (coord2[0] - coord1[0])) * 180 / np.pi - 90
        return distance, direction
    return None, None

# Initialize serial
ser = serial.Serial('/dev/ttyACM0', 9600, timeout=1.0)
time.sleep(3)
ser.reset_input_buffer()

# Initialize camera
camera = Picamera2()
camera.configure(camera.create_still_configuration())
camera.start()
sleep(1)  # allow warm-up

# Initial capture
camera.capture_file('prev.jpg')
prev = cv2.imread('prev.jpg')[100:1500, 300:1850]
prev = cv2.rotate(prev, cv2.ROTATE_90_CLOCKWISE)
cv2.imwrite('prev_crp.jpg', prev)
prev_coords = get_red_object_coordinates('prev_crp.jpg')

while True:
    # Capture new image
    camera.capture_file('curr.jpg')
    curr = cv2.imread('curr.jpg')[100:1500, 300:1850]
    curr = cv2.rotate(curr, cv2.ROTATE_90_CLOCKWISE)
    cv2.imwrite('curr_crp.jpg', curr)
    curr_coords = get_red_object_coordinates('curr_crp.jpg')

    # Compare
    distance, direction = calculate_movement(prev_coords, curr_coords)
    #print(f"{distance:.0f}, {direction:.0f}")
    

    # Send to Arduino or process here
    # ser.write(f"{distance},{direction}\n".encode())
    ser.write(f"{distance:.0f}, {direction:.0f}\n".encode('utf-8'))

    # Shift current to previous
    os.replace('curr_crp.jpg', 'prev_crp.jpg')
    prev_coords = curr_coords

    sleep(0.5)  # adjust this delay based on how fast you want to loop
